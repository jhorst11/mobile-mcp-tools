# Magen Template System – Requirements & Design Document (v1)

## 1. Overview

The Magen Template System is a **layered, platform-agnostic app templating engine** inspired by Docker's image layering. It enables:

- Buildable authoring instances
- Inline variable annotations
- Automatic schema extraction
- Layered template inheritance via diffs
- Full filename/project-file templating (including Xcode projects)
- CLI + TypeScript API for human and AI usage

This document defines the architecture, semantics, and behaviors of the system.

### Package Structure

The Magen Template System will be implemented as a new package: `magen-templates`

Templates are stored within the package at: `magen-templates/templates/`

This co-locates templates with the tooling, ensuring version consistency and simplifying distribution.

---

## 2. Core Concepts

### Template
A non-buildable structure containing Handlebars placeholders. Each template includes:

- `template.json` (metadata)
- `layer.patch` (diff vs parent)
- `template/` (canonical templated files)

Templates live within the `magen-templates` package at:

```
magen-templates/templates/<templateName>/
```

### Authoring Instance
A fully concrete buildable project generated by:

```
magen-template template create
magen-template template dev
```

Lives within each template's directory at:

```
magen-templates/templates/<templateName>/work/
```

Only the authoring instance is ever opened in Xcode or IDEs.

### Layering
Templates form a parent → child chain:

```
ios-base
   ↓ layer.patch
ios-salesforce
   ↓ layer.patch
ios-salesforce-offline
```

Materialization applies all patches in order before final templating.

**Patch Format**: All `layer.patch` files are git patch files created and applied exclusively using git tooling. No manual patch manipulation or custom diff formats are used.

---

## 3. Inline Annotation System

### Variable Definitions

```swift
let appName = "Magen Demo" // magen:var appName string required "Display name shown on the home screen"
```

Properties extracted:

- type
- required
- description
- default (from inline literal)

Literal rewritten to:

```swift
let appName = "{{appName}}"
```

### Extended Rules

```swift
// magen:regex orgId "^[0-9A-Za-z]+$"
// magen:enum environment dev staging prod
```

### Filename Templating

```swift
// magen:filename {{appName}}App.swift
```

On finalize:

- Template file renamed to `{{appName}}App.swift`
- `.pbxproj` references rewritten
- Authoring instance retains real file name (`MagenDemoApp.swift`)

---

## 4. template.json Schema

```jsonc
{
  "name": "ios-salesforce",
  "platform": "ios",
  "basedOn": "ios-base",
  "version": "0.1.0",

  "layer": {
    "patchFile": "layer.patch"
  },

  "variables": [
    {
      "name": "appName",
      "type": "string",
      "required": true,
      "description": "Display name shown on the home screen",
      "default": "Magen Demo"
    }
  ],

  "tags": ["salesforce", "auth"],
  "description": "iOS template integrating Salesforce SDK"
}
```

---

## 5. CLI Requirements

### Package CLI

The `magen-templates` package provides a CLI binary: `magen-template`

### Commands

| Command | Description |
|--------|-------------|
| `magen-template list` | List templates |
| `magen-template show <name>` | Show metadata/schema |
| `magen-template generate <template>` | Generate concrete app |
| `magen-template template create <name> --from <base>` | Create authoring instance |
| `magen-template template dev <name>` | Re-enter authoring mode |
| `magen-template template finalize <name>` | Extract schema, rewrite, compute patch |
| `magen-template template validate <name>` | Validate template |

### Finalize Pipeline

1. Scan annotations
2. Build variable schema
3. Rewrite literals → Handlebars
4. Rename template files
5. Rewrite `.xcodeproj` references
6. Create/overwrite `layer.patch` using `git diff`
7. Run structural validation

---

## 6. Programmatic API (TypeScript)

The `magen-templates` package exports a TypeScript API:

```ts
listTemplates(): Promise<TemplateDescriptor[]>;
getTemplate(name: string): Promise<TemplateDescriptor>;
generateApp(options: GenerateOptions): Promise<void>;
```

Used by AI agents and the CLI. Both share the same core implementation.

---

## 7. Git-Based Patch System

### Requirements
All patch operations must use native git tooling:

- **Patch Creation**: `git diff` (or `git format-patch` for more complex scenarios)
- **Patch Application**: `git apply`
- **Patch Format**: Standard git unified diff format

### Rationale
- Git's patch format handles all edge cases (binary files, renames, permissions, etc.)
- Git tooling is battle-tested and widely available
- No need to implement custom diff/patch logic
- Consistent behavior across platforms
- Better error reporting and conflict detection

### Implementation Constraints
- ❌ Do NOT manually parse or generate patch files
- ❌ Do NOT use custom diff algorithms
- ❌ Do NOT use third-party diff libraries (except as fallback for git operations)
- ✅ DO use git commands via child process execution
- ✅ DO preserve git's output for user-facing error messages
- ✅ DO verify git is available in the environment during initialization

---

## 8. Validation

### Structural Validation
- Missing variables
- Conflicting annotations
- Broken filename rewrites
- `.pbxproj` consistency checks (iOS)

---

## 8. Layering Behavior

### Patch Creation
During finalize of a derived template:

1. Initialize a temporary git repository
2. Materialize parent template as the base commit
3. Copy authoring instance files over parent (representing the child layer changes)
4. Use `git diff` to generate patch: `git diff --no-index parent/ authoring/` or stage changes and use `git diff --cached`
5. Save the git patch as `layer.patch`

**Implementation**: All patch creation must use git's native diff and patch generation. No manual diff parsing or custom patch formats.

### Patch Application
During generate or dev:

1. Materialize parent template to target directory
2. Apply `layer.patch` using `git apply --directory=<target>`
3. Apply next layer patches in sequence using `git apply`
4. Render Handlebars templates on final materialized content

**Implementation**: Use `git apply` for all patch operations. This ensures proper handling of file additions, deletions, renames, and binary files.

### Conflict Behavior
Any patch application failure (detected by `git apply` exit code):

- Fail immediately
- Report git's conflict output (which file/hunk)
- No auto-merge in v1

---

## 9. Directory Layout

### Package Structure

```
magen-templates/                    # New package
  package.json
  src/
    cli/                            # CLI implementation
    core/                           # Core template engine
  templates/                        # Template storage
    <templateName>/
      template.json
      layer.patch
      template/
        {{appName}}App.swift
        ...
      work/                         # Authoring instance (when active)
        MagenDemoApp.swift
        ...
        MyProject.xcodeproj/
```

### Template

```
magen-templates/templates/<templateName>/
  template.json
  layer.patch
  template/
    {{appName}}App.swift
    ...
```

### Authoring Instance

```
magen-templates/templates/<templateName>/work/
  MagenDemoApp.swift
  ...
  MyProject.xcodeproj/
```

---

## 10. Generation Workflow

1. Resolve template chain
2. Materialize base template
3. Apply patches
4. Render Handlebars
5. Output buildable project

---

## 11. Out of Scope (v1)

- Remote template registries
- Template renaming
- Multi-parent templates
- Intelligent merge conflict resolution
- Rebase workflow
- Hooks and validation commands (deferred to future version)

---
